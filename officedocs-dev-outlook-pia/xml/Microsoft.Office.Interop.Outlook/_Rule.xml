<Type Name="_Rule" FullName="Microsoft.Office.Interop.Outlook._Rule">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0fc7984ff84a0eea00858aa8ce56abf24313ff68" />
    <Meta Name="ms.sourcegitcommit" Value="372abf58b21f4fab503d106f0e8c8a2ac45f9332" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="zh-CN" />
    <Meta Name="ms.lasthandoff" Value="07/19/2018" />
    <Meta Name="ms.locfileid" Value="20631589" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface _Rule" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Rule" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Rule" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Rule" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Rule" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("000630CD-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="33880-101">这是与相应的 COM 对象的互操作性的托管代码需要 COM coclass 中的主接口。</span>
      <span class="sxs-lookup">
        <span data-stu-id="33880-101">This is a primary interface in a COM coclass that is required by managed code for interoperability with the corresponding COM object.</span>
      </span>
      <span data-ttu-id="33880-102">仅当您想要使用的方法共享相同的名称的 COM 对象; 事件时，才使用此主接口在这种情况下，强制转换为此接口调用方法，并强制转换为最新的事件接口，连接到该事件。</span>
      <span class="sxs-lookup">
        <span data-stu-id="33880-102">Use this primary interface only when the method you want to use shares the same name as an event of the COM object; in this case, cast to this interface to call the method, and cast to the latest events interface to connect to the event.</span>
      </span>
      <span data-ttu-id="33880-103">否则，使用.NET 接口派生自 COM coclass 访问方法、 属性和事件的 COM 对象。</span>
      <span class="sxs-lookup">
        <span data-stu-id="33880-103">Otherwise, use the .NET interface that is derived from the COM coclass to access methods, properties, and events of the COM object.</span>
      </span>
      <span data-ttu-id="33880-104">有关 COM 对象的信息，请参阅<see cref="T:Microsoft.Office.Interop.Outlook.Rule" />。</span>
      <span class="sxs-lookup">
        <span data-stu-id="33880-104">For information about the COM object, see <see cref="T:Microsoft.Office.Interop.Outlook.Rule" />.</span>
      </span>
    </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Actions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleActions Actions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleActions Actions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Actions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Actions As RuleActions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleActions ^ Actions { Microsoft::Office::Interop::Outlook::RuleActions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64272)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64272)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleActions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-105">返回<see cref="T:Microsoft.Office.Interop.Outlook.RuleActions" />集合对象，代表所有可用的规则操作的规则。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-105">Returns a <see cref="T:Microsoft.Office.Interop.Outlook.RuleActions" />  collection object that represents all the available rule actions for the rule.</span>
          </span>
          <span data-ttu-id="33880-106">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-106">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-107">
            <para>您可以枚举和启用规则与任何规则操作的规则和通知向导支持，但您可以编程方式创建具有仅的最常用的规则操作，而不是任何规则和通知向导支持的规则操作。规则操作支持的详细信息，请参阅<a href="http://go.microsoft.com/fwlink/?LinkId=87797">指定规则操作</a></para>
            <para>
              <b>操作</b>属性中，通过每个规则相关联<b>RuleActions</b>对象。<b>作为 RuleActions</b>集合是固定的对象-无法添加或移除此集合的项目。规则中启用的规则操作<b>作为 RuleActions</b>集合中都已启用的规则操作。在规则未启用的操作将具有的规则操作具有此集合中的规则<see cref="P:Microsoft.Office.Interop.Outlook._RuleAction.Enabled" />属性设置为<b>False</b>。编程规则创建过程中不支持的规则操作可以仅枚举现有规则，<b>作为 RuleActions</b>集合中，但<b>作为 RuleActions</b>集合固定的因为无法创建规则，并为其添加诸如操作关联<b>作为 RuleActions</b>集合。</para>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-107">
              <para>You can enumerate and enable rules with any rule action that the Rules and Alerts Wizard support, but you can programmatically  create rules that have only the most commonly used rule actions, and not any rule action that the Rules and Alerts Wizard supports. For more information on rule action support, see <a href="http://go.microsoft.com/fwlink/?LinkId=87797">Specify Rule Actions</a></para>
              <para>Through the <b>Actions</b> property, each rule is associated with a <b>RuleActions</b> object. The <b>RuleActions</b> collection is a fixed object - you cannot add or remove items from this collection. Rule actions that are enabled in the rule will have an enabled rule action in the <b>RuleActions</b> collection. Rule actions that are not enabled in the rule will have a rule action in this collection that has the <see cref="P:Microsoft.Office.Interop.Outlook._RuleAction.Enabled" /> property set to <b>False</b>. Rule actions that are not supported during programmatic rule creation can only be enumerated in the <b>RuleActions</b> collection for an existing rule, but because the <b>RuleActions</b> collection is fixed, you cannot create a rule and add such an action to the associated <b>RuleActions</b> collection.</para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-108">返回<see cref="T:Microsoft.Office.Interop.Outlook.Application" />表示 Outlook application 对象的父对象。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-108">Returns an <see cref="T:Microsoft.Office.Interop.Outlook.Application" />  object that represents the parent Outlook application for the  object.</span>
          </span>
          <span data-ttu-id="33880-109">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-109">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-110">返回<see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" />常量，指示对象的类。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-110">Returns an <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> constant indicating the object's class.</span>
          </span>
          <span data-ttu-id="33880-111">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-111">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Conditions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleConditions Conditions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleConditions Conditions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Conditions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Conditions As RuleConditions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleConditions ^ Conditions { Microsoft::Office::Interop::Outlook::RuleConditions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64297)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64297)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleConditions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-112">返回<see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" />集合对象，它代表规则的所有可用规则条件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-112">Returns a <see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" />  collection object that represents all the available rule conditions for the rule.</span>
          </span>
          <span data-ttu-id="33880-113">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-113">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-114">
            <para>规则条件表明应在其下应用规则的条件。两个<b>条件</b>和<see cref="P:Microsoft.Office.Interop.Outlook._Rule.Exceptions" />属性共享同一个池的条件并返回相应的<b>RuleConditions</b>集合对象。</para>但
          <para>以编程方式可以枚举和启用支持的规则和通知向导，任何规则条件的规则的规则和通知向导，可以创建具有只有最常用的规则条件，而不是任何规则条件的规则支持。规则条件支持的详细信息，请参阅<a href="http://go.microsoft.com/fwlink/?LinkId=87803">指定规则条件</a></para><para><b>条件</b>属性中，通过每个规则都与一个<b>RuleConditions</b>对象相关联。<b>RuleConditions</b>集合是固定的对象-无法添加或移除此集合的项目。规则中启用的规则条件中<b>作为 RuleConditions</b>集合都已启用的规则条件。未启用规则中的条件将具有的规则条件具有此集合中的规则<see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" />属性设置为<b>False</b>。编程规则创建过程中不支持的规则条件可以仅枚举现有规则， <b>RuleConditions</b>集合中，但<b>作为 RuleConditions</b>集合固定的因为无法创建规则，并添加此类条件到关联的<b>RuleConditions</b>集合。</para><para /></span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-114">
              <para>A condition for a rule states the condition under which the rule should be applied. Both the <b>Conditions</b> and <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Exceptions" /> properties share the same pool of conditions and return a corresponding  <b>RuleConditions</b> collection object.</para>
              <para>Programmatically you can enumerate and enable rules with any rule condition that the Rules and Alerts Wizard support, but you can  create rules that have only the most commonly used rule conditions, and not any rule condition that the Rules and Alerts Wizard supports. For more information on rule condition support, see <a href="http://go.microsoft.com/fwlink/?LinkId=87803">Specifying Rule Conditions</a></para>
              <para>Through the <b>Conditions</b> property, each rule is associated with a <b>RuleConditions</b> object. The <b>RuleConditions</b> collection is a fixed object - you cannot add or remove items from this collection. Rule conditions that are enabled in the rule will have an enabled rule condition in the <b>RuleConditions</b> collection. Rule conditions that are not enabled in the rule will have a rule condition in this collection that has the <see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" /> property set to <b>False</b>. Rule conditions that are not supported during programmatic rule creation can only be enumerated in the <b>RuleConditions</b> collection for an existing rule, but because the <b>RuleConditions</b> collection is fixed, you cannot create a rule and add such a condition to the associated <b>RuleConditions</b> collection.</para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-115">返回或设置一个<b>布尔</b>值 (C# 中<b>bool</b> ) 来确定是否要应用该规则。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-115">Returns or sets a <b>Boolean</b> value (<b>bool</b> in C#) that determines if the rule is to be applied.</span>
          </span>
          <span data-ttu-id="33880-116">为可读/写属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-116">Read/write.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-117">
            <para>规则的将<b>Enabled</b>属性设置不保证将启用该规则。之后才启用规则<see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" />执行成功。</para>
            <para>使用<b>Rule.Enabled</b><b>Rules.Save</b>将规则应用一致和仍然存在超出当前会话的规则。启用的规则 （已成功保存） 可以确保将应用规则。这是本地客户端规则，如果 Outlook 正在运行，并且如果规则是基于服务器的规则，它将应用无论是否正在运行 Outlook 时将应用规则。如果未启用规则，然后定义规则，但不是会应用。但是，您可以使用<see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" />应用规则作为一次性操作而不管是否启用规则。 </para>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-117">
              <para>Setting the <b>Enabled</b> property of a rule does not guarantee that the rule will be enabled. The rule is enabled only after <see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" /> executes successfully.</para>
              <para>Using <b>Rule.Enabled</b> and <b>Rules.Save</b> applies the rule consistently and persists the rules beyond the current session. Enabling a rule (that has been saved successfully) ensures that the rule will be applied. If it is a local client rule, the rule will be applied when Outlook is running, and if the rule is a server-based rule, it will be applied regardless of whether Outlook is running. If you do not enable the  rule, then the rule is defined, but it will not be applied. However, you can use <see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" /> to apply a rule as an one-off operation regardless of whether the rule is  enabled.  </para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exceptions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleConditions Exceptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleConditions Exceptions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Exceptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exceptions As RuleConditions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleConditions ^ Exceptions { Microsoft::Office::Interop::Outlook::RuleConditions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64307)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64307)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleConditions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-118">返回<see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" />集合对象，它代表规则的所有可用规则例外条件。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-118">Returns a <see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" />  collection object that represents all the available rule exception conditions for the rule.</span>
          </span>
          <span data-ttu-id="33880-119">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-119">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-120">
            <para>规则例外条件指明在其下不应应用该规则的条件。同时<see cref="P:Microsoft.Office.Interop.Outlook._Rule.Conditions" />和<b>例外</b>属性共享同一个池的条件并返回相应的<b>RuleConditions</b>集合对象。</para>
            <para>您可以枚举和启用规则的规则和通知向导支持，任何规则例外条件，但您可以编程方式创建具有只有最常用的规则例外条件，而不是任何规则例外条件的规则规则和通知向导支持。规则条件支持的详细信息，请参阅<a href="http://go.microsoft.com/fwlink/?LinkId=87803">指定规则条件</a></para>
            <para>
              <b>条件</b>属性中，通过每个规则都与一个<b>RuleConditions</b>对象相关联。<b>RuleConditions</b>集合是固定的对象-无法添加或移除此集合的项目。规则中启用的规则例外条件<b>作为 RuleConditions</b>集合中都启用的规则例外条件。在规则未启用的例外条件将具有规则例外条件具有此集合中的规则<see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" />属性设置为<b>False</b>。编程规则创建过程中不支持的规则例外条件可以仅枚举<b>RuleConditions</b>集合中的现有规则，但<b>作为 RuleConditions</b>集合固定的因为无法创建规则并将其添加到关联的<b>RuleConditions</b>集合的此类例外条件。</para>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-120">
              <para>An exception condition for a rule states the condition under which the rule should not be applied. Both the <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Conditions" /> and <b>Exceptions</b> properties share the same pool of conditions and return a corresponding  <b>RuleConditions</b> collection object.</para>
              <para>You can enumerate and enable rules with any rule exception condition that the Rules and Alerts Wizard support, but you can programmatically  create rules that have only the most commonly used rule exception conditions, and not any rule exception condition that the Rules and Alerts Wizard supports. For more information on rule condition support, see <a href="http://go.microsoft.com/fwlink/?LinkId=87803">Specifying Rule Conditions</a></para>
              <para>Through the <b>Conditions</b> property, each rule is associated with a <b>RuleConditions</b> object. The <b>RuleConditions</b> collection is a fixed object - you cannot add or remove items from this collection. Rule exception conditions that are enabled in the rule will have an enabled rule exception condition in the <b>RuleConditions</b> collection. Rule exception conditions that are not enabled in the rule will have a rule exception condition in this collection that has the <see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" /> property set to <b>False</b>. Rule exception conditions that are not supported during programmatic rule creation can only be enumerated in the <b>RuleConditions</b> collection for an existing rule, but because the <b>RuleConditions</b> collection is fixed, you cannot create a rule and add such an exception condition to the associated <b>RuleConditions</b> collection.</para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object ShowProgress, object Folder, object IncludeSubfolders, object RuleExecuteOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Execute([in]object ShowProgress, [in]object Folder, [in]object IncludeSubfolders, [in]object RuleExecuteOption) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (Optional ShowProgress As Object, Optional Folder As Object, Optional IncludeSubfolders As Object, Optional RuleExecuteOption As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64270)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ShowProgress" Type="System.Object" />
        <Parameter Name="Folder" Type="System.Object" />
        <Parameter Name="IncludeSubfolders" Type="System.Object" />
        <Parameter Name="RuleExecuteOption" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ShowProgress">
          <span data-ttu-id="33880-121">
            <b>True</b> 在执行规则时显示进度对话框， <b>False</b> 而不显示对话框中运行该规则。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-121">
              <b>True</b> to display the progress dialog box when the rule is executed, <b>False</b> to run the rule without displaying the dialog box.</span>
          </span>
        </param>
        <param name="Folder">
          <span data-ttu-id="33880-122">代表将要应用规则的文件夹。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-122">Represents the folder where the rule will be applied.</span>
          </span>
        </param>
        <param name="IncludeSubfolders">
          <span data-ttu-id="33880-123">
            <b>真</b> 要将规则应用于由 Folder参数，则该文件夹的子文件夹 <b>假</b> 以该规则仅应用于该文件夹中，但不是包括子文件夹。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-123">
              <b>True</b> to apply the rule to subfolders of the folder indicated by the Folder parameter; <b>False</b> to apply the rule only to that folder but not its subfolders.</span>
          </span>
        </param>
        <param name="RuleExecuteOption">
          <span data-ttu-id="33880-124">代表是否向由 Folder 和 IncludeSubfolders 参数指定的一个或多个文件夹中的已读邮件、未读邮件或所有邮件应用规则。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-124">Represents whether to apply the rule to read, unread, or all messages in the folder or folders specified by the Folder and IncludeSubfolders parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="33880-125">将规则作为一次性操作来应用。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-125">Applies a rule as an one-off operation.</span>
          </span>
        </summary>
        <remarks>
          <span data-ttu-id="33880-126">
            <para>使用<see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" />将规则作为一次性操作来无论是否应用<see cref="P:Microsoft.Office.Interop.Outlook._Rule.Enabled" />为<b>True</b>。使用<b>Rule.Enabled</b>然后<see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" />如果想要始终应用规则，并保留超出当前会话的规则。</para>
            <para>的<b>Execute</b>方法的参数是可选的。如果不指定任何参数，则规则将应用到收件箱中的所有消息，但不适用于收件箱的子文件夹。可选参数的默认值如下所示： </para>
            <list type="table">
              <item>
                <description>参数</description>
                <description>默认值</description>
              </item>
              <item>
                <description>ShowProgress</description>
                <description>False</description>
              </item>
              <item>
                <description>文件夹</description>
                <description>收件箱</description>
              </item>
              <item>
                <description>IncludeSubfolders</description>
                <description>False</description>
              </item>
              <item>
                <description>RuleExecuteOption</description>
                <description>
                  <b>OlRuleExecuteOption.olRuleExecuteAllMessages</b>
                </description>
              </item>
            </list>
            <para>如果<paramref name="ShowProgress" />为<b>True</b> ，并且用户取消进度对话框中，规则执行相同的方式取消了就好像用户已取消通过规则和通知向导执行规则。执行用户取消进度对话框时将返回错误。</para>
            <para>如果您打算显示自定义进度用户界面而不是使用进度对话框，您应了解没有表示当规则执行启动事件和停止。</para>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-126">
              <para>Use <see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" /> to apply a rule as a one-off operation regardless of whether <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Enabled" /> is <b>True</b>. Use <b>Rule.Enabled</b> and then <see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" /> if you want to apply the rule consistently and persist the rules beyond the current session.</para>
              <para>The parameters to the <b>Execute</b> method are optional. If you do not specify any parameters, the rule will be applied to all messages in the Inbox but not to the subfolders of the Inbox. The default values for the optional arguments are as follows: </para>
              <list type="table">
                <item>
                  <description>Parameter</description>
                  <description>Default Value</description>
                </item>
                <item>
                  <description>ShowProgress</description>
                  <description>False</description>
                </item>
                <item>
                  <description>Folder</description>
                  <description>Inbox</description>
                </item>
                <item>
                  <description>IncludeSubfolders</description>
                  <description>False</description>
                </item>
                <item>
                  <description>RuleExecuteOption</description>
                  <description>
                    <b>OlRuleExecuteOption.olRuleExecuteAllMessages</b>
                  </description>
                </item>
              </list>
              <para>If <paramref name="ShowProgress" /> is <b>True</b> and the user cancels the progress dialog box, rule execution is canceled in the same manner as if the user had canceled rule execution through the Rules and Alerts Wizard. Execute returns an error when the user cancels the progress dialog.</para>
              <para>If you plan to show a custom progress user interface instead of using the progress dialog box, you should be aware that there are no events that indicate when rule execution starts and stops. </para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecutionOrder">
      <MemberSignature Language="C#" Value="public int ExecutionOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExecutionOrder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.ExecutionOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property ExecutionOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExecutionOrder { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-127">返回或设置 (C# 中<b>int</b> ) 的<b>整数</b>值，该值指示执行之间中其他规则的规则的顺序<see cref="T:Microsoft.Office.Interop.Outlook.Rules" />集合。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-127">Returns or sets an <b>Integer</b> (<b>int</b> in C#) value that indicates the order of execution of the rule among other rules in the <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> collection.</span>
          </span>
          <span data-ttu-id="33880-128">为可读/写属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-128">Read/write.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-129">
            <para>
              <b>ExecutionOrder</b>直接映射的数字值<paramref name="Index" />的<see cref="P:Microsoft.Office.Interop.Outlook._Rules.Item(System.Object)" />。例如，Rules.Item(1) 与<b>ExecutionOrder</b>正在 1 代表一个规则、 Rules.Item(2) 与<b>ExecutionOrder</b>正在 2，代表一个规则和 Rules.Item(Rules.Count) 代表<b>ExecutionOrder</b>正在的规则<see cref="P:Microsoft.Office.Interop.Outlook._Rules.Count" />。</para>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-129">
              <para>
                <b>ExecutionOrder</b> is directly mapped with the numerical value of  <paramref name="Index" /> in <see cref="P:Microsoft.Office.Interop.Outlook._Rules.Item(System.Object)" />. For example, Rules.Item(1) represents a rule with <b>ExecutionOrder</b> being 1, Rules.Item(2) represents a rule with <b>ExecutionOrder</b> being 2, and Rules.Item(Rules.Count) represents the rule with <b>ExecutionOrder</b> being <see cref="P:Microsoft.Office.Interop.Outlook._Rules.Count" />.</para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalRule">
      <MemberSignature Language="C#" Value="public bool IsLocalRule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalRule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.IsLocalRule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocalRule As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocalRule { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64269)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64269)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-130">返回<b>Boolean</b> (C# 中<b>bool</b> )，该值指示是否该规则将执行作为客户端规则。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-130">Returns a <b>Boolean</b> (<b>bool</b> in C#) that indicates if the rule executes as a client-side rule.</span>
          </span>
          <span data-ttu-id="33880-131">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-131">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-132">
            <para>客户端规则执行仅在运行 Outlook 时。如果<b>IsLocalRule</b>为<b>False</b>，则该规则将执行服务器端规则作为。</para>如果您有 Microsoft Exchange Server 电子邮件帐户的
          <para>，服务器可以应用服务器端规则消息即使您没有运行 Outlook。必须设置规则它们被传递到收件箱的服务器上，并且必须能够在服务器上完成运行规则时要应用于邮件。例如，规则不能在上完成运行服务器如果操作指定打印邮件。启动 Outlook 时应用的服务器上，不能应用规则，如果。</para><para>如果存储区中的规则集合包含服务器和客户端规则，则服务器端规则将应用首先，客户端规则后跟。</para><para /></span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-132">
              <para>A client-side rule executes only when Outlook is running. If <b>IsLocalRule</b> is <b>False</b>, then the rule executes as a server-side rule.</para>
              <para>If you have a Microsoft Exchange Server e-mail account, the server can apply server-side rules to your messages even if you don't have Outlook running. The rules must be set to be applied to messages when they are delivered to your Inbox on the server, and the rules must be able to run to completion on the server. For example, a rule cannot run to completion on the server if the action specifies that a message be printed. If a rule cannot be applied on the server, it is applied when you start Outlook.</para>
              <para>If the rules collection on a store contains both server and client-side rules, the server-side rules are applied first, followed by the client-side rules.</para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-133">返回或设置一个<b>字符串</b>（C# 中的<b>字符串</b>） 表示的规则的名称。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-133">Returns or sets a <b>String</b> (<b>string</b> in C#) representing the name of the rule.</span>
          </span>
          <span data-ttu-id="33880-134">为可读/写属性。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-134">Read/write.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-135">
            <para>
              <b>名称</b>是默认属性和索引器中的某个规则的<see cref="T:Microsoft.Office.Interop.Outlook.Rules" />集合对象。对应于<b>PidTagRuleMsgName</b> (0x65EC001E)。</para>
            <para>规则的名称不唯一同一集合中的规则。</para>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-135">
              <para>
                <b>Name</b> is the default property and an indexer for a rule in a <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> collection object. It corresponds to <b>PidTagRuleMsgName</b> (0x65EC001E).</para>
              <para>Rule names are not unique among rules in the same collection.</para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-p111">返回指定对象的 <b>对象</b> 的父级。只读的。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-p111">Returns the parent <b>Object</b> of the specified object. Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-138">
            <para>父对象的<see cref="T:Microsoft.Office.Interop.Outlook.Rule" />对象是<see cref="T:Microsoft.Office.Interop.Outlook.Rules" />对象。</para>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-138">
              <para>The parent of the <see cref="T:Microsoft.Office.Interop.Outlook.Rule" /> object is the <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> object.</para>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RuleType">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlRuleType RuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlRuleType RuleType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.RuleType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RuleType As OlRuleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlRuleType RuleType { Microsoft::Office::Interop::Outlook::OlRuleType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64268)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64268)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlRuleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-139">返回一个常量从<see cref="T:Microsoft.Office.Interop.Outlook.OlRuleType" />枚举，指示是否规则应用于邮件正在发送或接收。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-139">Returns a constant from the <see cref="T:Microsoft.Office.Interop.Outlook.OlRuleType" /> enumeration that indicates if the rule applies to messages that are being sent or received.</span>
          </span>
          <span data-ttu-id="33880-140">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-140">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="33880-141">返回<see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" />对象的当前会话。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-141">Returns the <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" />  object for the current session.</span>
          </span>
          <span data-ttu-id="33880-142">只读。</span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-142">Read-only.</span>
          </span>
        </summary>
        <value>To be added.</value>
        <remarks>
          <span data-ttu-id="33880-143">
            <para>
              <b>Session</b>属性和<see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" />可以交替使用方法来获取当前会话的<b>NameSpace</b>对象。这两个成员的作用相同。例如，以下语句对执行相同的功能：</para>
            <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
            <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
            <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
            <code>Outlook.NameSpace objSession = Application.Session;</code>
            <para />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="33880-143">
              <para>The <b>Session</b> property and the <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> method can be used interchangeably to obtain the <b>NameSpace</b> object for the current session. Both members serve the same purpose. For example, the following pairs of statements perform the same function:</para>
              <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
              <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
              <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
              <code>Outlook.NameSpace objSession = Application.Session;</code>
              <para />
            </span>
          </span>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>